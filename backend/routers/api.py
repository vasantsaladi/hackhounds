from fastapi import APIRouter, Body
from models.schemas import ContentRequest
from services.processor import process_webpage_content, last_processed
from services.generator import generate_image
from datetime import datetime

router = APIRouter()

# Store the last received text for testing purposes
last_received_text = {"text": "", "url": "", "timestamp": None}

@router.post("/store-content")
async def store_content(content: ContentRequest):
    """
    Store webpage content for later processing with OpenAI and image generation.
    This endpoint receives text from the Chrome extension and saves it for
    future processing with our image generation model.
    """
    global last_received_text
    
    # Store the received text
    last_received_text = {
        "text": content.text,
        "url": content.url,
        "timestamp": datetime.now().isoformat()
    }
    
    # Log receipt of content
    print(f"Received {len(content.text)} characters from {content.url}")
    
    # Return simple confirmation
    return {"success": True, "message": "Content stored for future processing"}

@router.get("/last-content")
async def get_last_content():
    """
    Get the last received content from a webpage.
    This endpoint is useful for testing that your Chrome extension
    is successfully extracting and sending text.
    """
    return last_received_text

@router.post("/process-content")
async def process_content():
    """
    Process the last stored content using OpenAI to generate a title,
    description, and image prompt.
    """
    if not last_received_text["text"]:
        return {"error": "No content has been stored yet"}
    
    result = await process_webpage_content(
        text=last_received_text["text"],
        url=last_received_text["url"]
    )
    
    # Add the timestamp and source URL to the response
    result["processed_at"] = datetime.now().isoformat()
    result["source_url"] = last_received_text["url"]
    
    # Explicitly update the last_processed variable here
    global last_processed
    last_processed.update(result)
    
    return result

@router.get("/last-processed")
async def get_last_processed():
    """
    Get the last processed content from OpenAI.
    This endpoint returns the title, description, and image prompt
    that were generated by the LangChain model.
    """
    if not last_processed["title"]:
        return {"message": "No content has been processed yet"}
    
    return last_processed

@router.post("/generate-image")
async def generate_image_endpoint():
    """
    Generate an image using the prompt from the processed content.
    """
    if not last_processed.get("prompt"):
        return {"error": "No content has been processed yet"}
    
    image_url = await generate_image(last_processed["prompt"])
    
    return {"image_url": image_url}

@router.post("/preview-image")
async def show_image_endpoint(image_url: str = Body(...)):
    """
    Take an image URL and return HTML to display it in the frontend
    """
    # Return HTML that can be injected into the extension
    html = f"""
    <div class="image-preview">
        <img src="{image_url}" alt="Generated image" style="max-width: 100%; border-radius: 8px;">
    </div>
    """
    return {"html": html}

@router.post("/chain")
async def chain_actions(content: ContentRequest = None):
    """
    Chain all actions: process content, generate image, and return results.
    Can either use previously stored content or accept new content directly.
    """
    global last_received_text
    
    # If content is provided directly, store it first
    if content:
        # Store the received text
        last_received_text = {
            "text": content.text,
            "url": content.url,
            "timestamp": datetime.now().isoformat()
        }
        
        # Log receipt of content
        print(f"Chain received {len(content.text)} characters from {content.url}")
    
    # Check if we have content to process
    if not last_received_text["text"]:
        return {"error": "No content has been stored yet"}
    
    # Process the content
    process_result = await process_content()
    
    # If processing was successful, generate an image
    if "title" in process_result:
        image_result = await generate_image_endpoint()
        
        # Combine results
        return {
            "processed_content": process_result,
            "image": image_result
        }
    
    # If we get here, something went wrong with processing
    return {"error": "Failed to process content", "details": process_result}
